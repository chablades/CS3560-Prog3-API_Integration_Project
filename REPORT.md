# Project Report for AI World Builder

## Program Created By:
Diego Mejia  
Nicolas Tran

## Overview
AI World Builder is a Java application that allows users to create, edit and manage AI-generated stories.  
The system uses a clean MVC architecture, persistent local storage, and a streaming AI service to generate chapter 
content in real time.

The project includes:
 - UI to help navigate through the project (Menu, Editor, Settings)
 - Persistence layer for stories, chapters, and storage
 - An AI service that streams tokens from a provider (personal API key required)
 - A full JUnit test suite

## Challenges & Fixes
**Challenge:** Java Swing's JTextArea and JTextField doesn't support undo/redo nor placeholder texts by default
- **Fix:** The PlaceholderTextArea and PlaceholderTextField classes were created, which implement those two functionalities so they can be reused throughout the program

**Challenge:** MainController and Main View components would get bloated especially once the Story Editor is implemented
- **Fix:** The GUI and controller aspect of the program was split into two parts: Main and Editor. They each have their own controller and main GUI, and they separate the concerns between the main menu and the editor window.

**Challenge:** Given that this program requires an API key, we wanted to find a more user friendly way to store the API key in the user's local file structure without having to create config properties
- **Fix:** Global settings are persisted and this includes the API key field, which can be edited through the app's interface

**Challenge:** OpenAI's API was paid, which would get costly after testing numerous times
- **Fix:** The Google's Gemini API is used for this program, which is free but comes with rate limits.

**Challenge:** File loading (mainly for persistence) and ImageLoading (for GUI) often had repetitive lines of code which would bloat many files such as GUI components and StoryManager.
- **Fix:** Utility classes such as FileUtils and ImageLoader were made in order to abstract repetitive code and expose only necessary functions and parameters to the rest of the program.

## Design Pattern Justifications
### MVC (Model-View-Controller)
#### - Model: String 
#### - View: Swing UI pages
#### - Controller: MainController, EditorController

The app has clear separation between data, UI, and logic.
Controllers mediate between models and views, keeping the UI thin and testable.



## OOP Four Pillars
### 1. Encapsulation
- Persistence logic is hidden behind *Story Manager* and *AppSettingsManager*
- UI logic is encapsulated in *AIService* and *GeminiClient*
- UI logic is encapsulated in Swing pages

### 2. Inheritance
- Controllers implemented shared interfaces (*Editor Controller Interface*, *MainControllerInterface*)
### 3. Polymorphism
- Any class implementing *AIStreamLisenter* can receive streaming tokens.
- Any class implementing *EditorViewInterface* can be plugged into Editor Controller
- Strategy patern uses polymorphism to support multiple AI providerfs
### 4. Abstraction
- Controllers don't know how persistence work since they call manager classes
- Views don't know how AI works - they call controller methods
- AIService abstracts away the details of the Gemini API


## AI Usage

Copilot/ChatGPT was used for clarification, debugging, and architectural guidance. AI tools were also used as a learning
aid to understand the topics of this project more deeply. For example, understanding the api and service folder in terms
of its separation of concerns and how it transforms raw API output into data forms readable by the rest of the program.

Completions were used for small snippets, but all snippets were reviewed, modified, or rewritten in order to adapt to the rest of the program and we also fully understand the included code. No full solutions or full files were generated by AI.
## Demo Video
